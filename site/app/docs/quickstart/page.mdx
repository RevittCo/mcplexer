import { Callout } from "@/components/docs/callout";
import { TerminalBlock } from "@/components/docs/terminal-block";
import { PrevNextNav } from "@/components/docs/prev-next-nav";

# Quickstart

Two commands. Clone, run.

<TerminalBlock title="terminal">
{`git clone https://github.com/revittco/mcplexer.git
cd mcplexer
make electron-run`}
</TerminalBlock>

`make electron-run` builds the Go binary, web UI, and launches the MCPlexer desktop app with system tray integration, native notifications, and the full dashboard.

<Callout type="info" title="Prerequisites">
  Go 1.25+ and Node.js 20+ must be installed.
</Callout>

---

## What just happened?

`make electron-run` built everything and started the desktop app, which:

1. **Compiled the Go binary** and **built the web UI**
2. **Started MCPlexer** as a child process
3. **Opened the dashboard** in a native window with system tray

### Headless / CLI-only alternative

If you don't need the desktop app, you can run MCPlexer as a background daemon instead:

<TerminalBlock title="terminal">
{`make install`}
</TerminalBlock>

This builds, starts the daemon, configures Claude Desktop, and opens the dashboard at [http://localhost:3333](http://localhost:3333). Restart Claude Desktop and you're live.

## Add your first downstream server

Open the desktop app (or [http://localhost:3333](http://localhost:3333)) and use **Quick Setup** to connect a downstream MCP server with OAuth — GitHub, Linear, ClickUp, and more are supported out of the box. Click through, authorize, and you're connected.

For servers without OAuth, go to **Downstream Servers** in the sidebar, click **Add Server**, and fill in the details. The UI handles creating the route rules and auth scopes for you.

<Callout type="tip" title="Prefer the UI">
  The desktop app and web UI are the easiest way to manage MCPlexer. Everything you can do in YAML or the CLI, you can do from the UI — and it validates as you go.
</Callout>

### Alternative: YAML config

If you prefer config-as-code, add servers to `mcplexer.yaml`:

```yaml
downstream_servers:
  - id: github
    name: GitHub MCP
    transport: stdio
    command: npx
    args: ["-y", "@modelcontextprotocol/server-github"]
    tool_namespace: github
```

Then restart the daemon:

<TerminalBlock title="terminal">
{`make run`}
</TerminalBlock>

## Verify it works

<TerminalBlock title="terminal">
{`mcplexer status

# MCPlexer Status (db: ~/.mcplexer/mcplexer.db)
#   Workspaces:         1
#   Downstream servers: 1
#   Auth scopes:        0
#   Active sessions:    0`}
</TerminalBlock>

## How a tool call flows

Once connected, here's what happens when Claude calls a tool:

1. **Client sends request** — e.g., `github__list_repos` via MCP
2. **Workspace resolved** — matched by working directory
3. **Route matched** — finds the rule for this tool in this workspace
4. **Credentials injected** — env vars or OAuth tokens applied
5. **Forwarded downstream** — MCPlexer calls the GitHub MCP server
6. **Response returned** — result flows back to Claude
7. **Audit logged** — full call recorded with secrets redacted

## Next steps

- [Concepts](/docs/concepts) — understand the architecture
- [Configuration](/docs/configuration) — customize your setup
- [Routing](/docs/routing) — control which tools are available where
- [Authentication](/docs/authentication) — set up OAuth and credentials

<PrevNextNav />
