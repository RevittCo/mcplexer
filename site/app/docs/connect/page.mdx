import { Callout } from "@/components/docs/callout";
import { TerminalBlock } from "@/components/docs/terminal-block";
import { PropTable } from "@/components/docs/prop-table";
import { PrevNextNav } from "@/components/docs/prev-next-nav";

# Connect / Bridge

The `mcplexer connect` command bridges stdin/stdout to a running MCPlexer daemon over a Unix socket. This lets AI clients that only support stdio-based MCP servers communicate with a long-running MCPlexer instance.

## Why Connect?

MCPlexer can run in two modes:

- **Direct stdio** — `mcplexer serve --mode=stdio` starts a fresh instance per client session
- **Daemon + connect** — the daemon runs persistently, and `mcplexer connect` bridges individual clients to it

The daemon approach is preferred for production use because downstream server processes persist across client sessions, caches stay warm, and configuration changes take effect immediately without restarting clients.

## Usage

Connect to a running daemon via its Unix socket:

<TerminalBlock title="terminal">
{`mcplexer connect --socket=/path/to/mcplexer.sock`}
</TerminalBlock>

<PropTable props={[
  { name: "--socket", type: "string", description: "Path to the MCPlexer daemon's Unix socket. Can also be set via MCPLEXER_SOCKET_PATH." },
]} />

The default socket location is `/tmp/mcplexer.sock` when the daemon is started with default settings.

<TerminalBlock title="terminal">
{`# Start the daemon
mcplexer daemon start

# In another terminal, connect a stdio bridge
mcplexer connect --socket=/tmp/mcplexer.sock`}
</TerminalBlock>

## CWD Injection

When `mcplexer connect` starts, it passes the client's current working directory to the daemon via the `MCPLEXER_CLIENT_CWD` environment variable. The daemon uses this to resolve which workspace the client belongs to.

This means workspace matching works correctly even though the daemon runs as a separate process — it knows where the client is working from.

<TerminalBlock title="how CWD flows">
{`# Client is in /home/dev/projects/api-service
cd /home/dev/projects/api-service
mcplexer connect --socket=/tmp/mcplexer.sock

# Daemon receives MCPLEXER_CLIENT_CWD=/home/dev/projects/api-service
# Matches workspace with root: /home/dev/projects/api-service`}
</TerminalBlock>

## Claude Desktop Integration

To use daemon mode with Claude Desktop, configure `mcplexer connect` as the MCP server command:

```json
{
  "mcpServers": {
    "mx": {
      "command": "mcplexer",
      "args": ["connect", "--socket", "/tmp/mcplexer.sock"]
    }
  }
}
```

<Callout type="info" title="Config file location">
  On macOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
</Callout>

With this setup, Claude Desktop launches `mcplexer connect` which bridges to your running daemon. The daemon manages all downstream servers, caching, and routing.

## When to Use Connect vs Direct Stdio

| Scenario | Recommended Mode |
|---|---|
| Single developer, simple setup | Direct stdio (`serve --mode=stdio`) |
| Multiple clients sharing state | Daemon + connect |
| Persistent downstream processes | Daemon + connect |
| Warm caches across sessions | Daemon + connect |
| Quick testing or evaluation | Direct stdio |

<Callout type="tip" title="Start simple">
  If you're just getting started, use direct stdio mode. Switch to daemon + connect when you need persistent processes, shared caches, or multiple concurrent clients.
</Callout>

<PrevNextNav />
