package secrets

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"

	"filippo.io/age"
)

// AgeEncryptor encrypts and decrypts data using the age library.
type AgeEncryptor struct {
	identity  age.Identity
	recipient age.Recipient
}

// NewAgeEncryptor creates an AgeEncryptor from a key file path.
// The file should contain an age identity (private key).
func NewAgeEncryptor(keyPath string) (*AgeEncryptor, error) {
	data, err := os.ReadFile(keyPath)
	if err != nil {
		return nil, fmt.Errorf("read age key file: %w", err)
	}
	return NewAgeEncryptorFromKey(string(data))
}

// NewAgeEncryptorFromKey creates an AgeEncryptor from a raw key string.
func NewAgeEncryptorFromKey(key string) (*AgeEncryptor, error) {
	identities, err := age.ParseIdentities(strings.NewReader(key))
	if err != nil {
		return nil, fmt.Errorf("parse age identity: %w", err)
	}
	if len(identities) == 0 {
		return nil, fmt.Errorf("no age identities found in key")
	}

	identity := identities[0]
	recipient, ok := identity.(*age.X25519Identity)
	if !ok {
		return nil, fmt.Errorf("unsupported age identity type")
	}

	return &AgeEncryptor{
		identity:  identity,
		recipient: recipient.Recipient(),
	}, nil
}

// NewEphemeralEncryptor creates an AgeEncryptor with an in-memory generated key.
// Tokens encrypted with this key are lost on restart. Useful for dev/testing.
func NewEphemeralEncryptor() (*AgeEncryptor, error) {
	id, err := age.GenerateX25519Identity()
	if err != nil {
		return nil, fmt.Errorf("generate ephemeral age key: %w", err)
	}
	return &AgeEncryptor{
		identity:  id,
		recipient: id.Recipient(),
	}, nil
}

// EnsureKeyFile loads an existing age key file, or generates a new one and
// writes it to keyPath. This gives persistent encryption across restarts
// without requiring manual key management.
func EnsureKeyFile(keyPath string) (*AgeEncryptor, error) {
	if data, err := os.ReadFile(keyPath); err == nil {
		return NewAgeEncryptorFromKey(string(data))
	}

	id, err := age.GenerateX25519Identity()
	if err != nil {
		return nil, fmt.Errorf("generate age key: %w", err)
	}

	content := fmt.Sprintf("# auto-generated by mcplexer\n# public key: %s\n%s\n",
		id.Recipient(), id)
	if err := os.WriteFile(keyPath, []byte(content), 0600); err != nil {
		return nil, fmt.Errorf("write age key file: %w", err)
	}

	return &AgeEncryptor{
		identity:  id,
		recipient: id.Recipient(),
	}, nil
}

// Encrypt encrypts plaintext using the age recipient.
func (e *AgeEncryptor) Encrypt(plaintext []byte) ([]byte, error) {
	var buf bytes.Buffer
	w, err := age.Encrypt(&buf, e.recipient)
	if err != nil {
		return nil, fmt.Errorf("create age writer: %w", err)
	}
	if _, err := w.Write(plaintext); err != nil {
		return nil, fmt.Errorf("write plaintext: %w", err)
	}
	if err := w.Close(); err != nil {
		return nil, fmt.Errorf("close age writer: %w", err)
	}
	return buf.Bytes(), nil
}

// Decrypt decrypts ciphertext using the age identity.
func (e *AgeEncryptor) Decrypt(ciphertext []byte) ([]byte, error) {
	r, err := age.Decrypt(bytes.NewReader(ciphertext), e.identity)
	if err != nil {
		return nil, fmt.Errorf("create age reader: %w", err)
	}
	plaintext, err := io.ReadAll(r)
	if err != nil {
		return nil, fmt.Errorf("read decrypted data: %w", err)
	}
	return plaintext, nil
}
